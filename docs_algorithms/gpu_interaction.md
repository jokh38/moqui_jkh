## MOQUI의 GPU 기반 물질 상호작용 계산 메커니즘

이 문서는 몬테카를로 시뮬레이션 코드 MOQUI가 GPU(Graphics Processing Unit)의 병렬 처리 능력을 극대화하여 입자와 물질의 상호작용을 어떻게 효율적으로 계산하는지에 대한 종합적인 설명서입니다.

---
### **핵심 철학: 왜 화학 조성이 아닌 CT 값을 사용하는가?**

전통적인 연구용 몬테카를로 코드(TOPAS 등)는 사용자가 기하학적 구조를 정의하고 각 부분의 화학 조성을 직접 입력합니다. 반면, MOQUI는 임상 환경에 맞춰 환자의 CT(Computed Tomography) 영상 데이터를 직접 사용하는 방식을 채택했습니다. 이는 다음과 같은 결정적인 이점을 제공합니다.

1.  **임상 워크플로우 연동**: 방사선 치료 계획은 항상 환자의 CT 영상에서 시작됩니다. MOQUI는 이 데이터를 직접 입력받아 처리하므로, 복잡한 데이터 변환이나 수동 분할(segmentation) 작업 없이 신속한 계획 수립이 가능합니다.
2.  **환자 고유의 불균일성 반영**: 인체는 균일한 물질의 조합이 아닙니다. CT의 HU(Hounsfield Unit) 값은 복셀(voxel) 단위로 조직의 미세한 밀도 변화를 정밀하게 표현하며, MOQUI는 이 정보를 그대로 활용하여 환자 맞춤형의 정확한 선량 계산을 수행합니다.
3.  **GPU 최적화된 데이터 구조**: CT 데이터는 GPU가 가장 효율적으로 처리할 수 있는 거대하고 균일한 3차원 숫자 배열 형태이므로, 병렬 처리에 완벽하게 부합합니다.



---
### **계산 전략: 오프라인 준비와 실시간 실행의 분리**

MOQUI의 효율성은 계산 과정을 **①오프라인 준비 단계**와 **②실시간 GPU 실행 단계**로 영리하게 분리한 데서 나옵니다.

#### **1단계: 오프라인 준비 (물리 모델 교정)**
GPU가 실시간으로 계산에 집중할 수 있도록, 복잡한 물리 모델 분석은 시뮬레이션 실행 전 오프라인에서 미리 수행합니다.

* **데이터 생성**: TOPAS와 같은 신뢰도 높은 코드를 사용하여, 다양한 물질(HU값으로 대표)과 에너지에 따른 저지능(Stopping Power) 참조 데이터를 생성합니다. 이 데이터는 `(HU, 에너지) → 저지능`의 다차원 관계를 가집니다.
* **핵심 근사 (커브 피팅)**: 이 다차원 데이터를 분석하여, 에너지에 따른 변화가 비교적 적은 **상대 저지능비(RSP)** 값을 계산합니다. 그 후, 에너지 변수를 특정 값(예: 기준 에너지)으로 고정하거나 평균을 내어, 최종적으로 **`RSP = f(HU)`** 라는 **하나의 입력 변수에 대한 단순한 2차원 함수**를 도출합니다.
* **결과물**: 이 커브 피팅을 통해 얻어진 몇 개의 **함수 계수(coefficients)**가 MOQUI 코드(`patient_material.cu`)에 탑재될 최종 결과물입니다.

#### **2단계: 실시간 실행 (GPU 커널)**
실제 시뮬레이션이 시작되면, GPU는 오프라인에서 준비된 단순화된 모델을 이용해 빛의 속도로 계산을 수행합니다.

* **입자 수송**: **델타 트래킹(Delta Tracking)** 알고리즘을 사용하여 복잡한 경계면 계산 없이 입자를 효율적으로 이동시킵니다.
* **최적화된 저지능 계산 루프**: 입자가 에너지를 잃는 과정은 다음과 같은 고도로 최적화된 루프를 통해 계산됩니다.

    1.  **복셀 진입 (1회 계산)**: 입자가 새로운 복셀에 진입하면, 해당 복셀의 HU 값을 **`RSP = f(HU)`** 함수에 단 한 번 대입하여 고유 RSP 값을 계산하고 스레드의 빠른 메모리에 저장합니다.
    2.  **복셀 내 이동 (반복 계산)**: 복셀 내부를 이동하는 매 스텝(step)마다, 입자의 현재 에너지($E$)를 **1차원 '에너지-물 저지능' 룩업 테이블($S_{water}(E)$)**에서 매우 빠르게 조회합니다.
    3.  **최종 계산**: `최종 저지능 = (저장된 RSP) × S_water(E)` 라는 단순 곱셈으로 최종 저지능을 계산하여 입자의 에너지를 업데이트합니다.

이 방식은 비유하자면, **도시에 진입할 때 그 도시의 고유한 교통 패널티(RSP)를 한 번만 확인**하고, **주행 중에는 계속 변하는 내 차의 속도계(에너지)에 따른 기본 연비($S_{water}(E)$)만**을 참고하여 총연비를 계산하는 효율적인 운전 방식과 같습니다.



---
### **성능 분석: MOQUI는 왜 빠른가?**

MOQUI의 RSP 기반 계산 방식은 다른 이론적인 접근법들과 비교했을 때, GPU 아키텍처에 대한 깊은 이해를 바탕으로 설계된 최적의 해법입니다.

| 구분 | **A. 현재 MOQUI 방식 (RSP)** | **B. 2D 테이블 방식** | **C. '완벽한 함수' 방식** |
| :--- | :--- | :--- | :--- |
| **메모리 사용량**| **최소 (수십 KB)** | **최대 (수십 MB)** | **최소 (상수 몇 개)** |
| **연산 복잡도** | **최저** (단순 곱셈/덧셈) | **없음** (값만 가져옴) | **최고** (복잡한 수학 함수) |
| **스레드 분기** | **없음** | **없음** | **높음** (에너지별 조건문) |
| **성능 병목** | 없음 | **메모리 지연** | **연산 비용 + 분기** |
| **최종 성능** | **가장 빠름 🥇** | **가장 느림 🐢** | **중간 🥈** |

* **2D 테이블 방식**은 거대한 테이블 크기로 인해 GPU의 빠른 캐시 메모리를 활용하지 못하고, 느린 VRAM에 접근해야 하므로 **메모리 지연(latency)** 때문에 극도로 느려집니다.
* **'완벽한 함수' 방식**은 메모리 문제는 해결하지만, 복잡한 수학 연산과 에너지 구간별 조건문으로 인한 **스레드 분기(thread divergence)**가 발생하여 GPU의 병렬 처리 효율을 심각하게 저하시킵니다.
* **MOQUI의 방식**은 이 두 가지 문제를 모두 회피합니다. 작은 메모리 사용으로 **캐시를 최대한 활용**하고, 단순 연산과 **분기 없는 구조**로 GPU가 가장 좋아하는 형태의 작업을 제공하여 최고의 성능을 이끌어냅니다.

---
### **결론**

MOQUI의 물질 상호작용 계산 방식은 물리적 정확성과 계산 효율성 사이의 매우 영리한 공학적 절충안입니다. 복잡한 물리 현상을 **'물질 의존성'과 '에너지 의존성'으로 분리**하고, 이를 GPU 아키텍처에 최적화된 단순한 계산들의 조합으로 재구성함으로써, 임상 환경에서 요구되는 **정확성, 속도, 안정성**을 모두 만족시키는 고성능 컴퓨팅의 정수를 보여줍니다.