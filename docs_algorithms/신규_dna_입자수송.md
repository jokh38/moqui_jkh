## GPU 기반 Event-by-Event 입자 수송 방식 설계 문서

### 1\. 개요

#### 1.1. 목표

본 문서는 **Geant4-DNA** 및 **TOPAS-nBio**와 같은 CPU 기반 시뮬레이션의 높은 물리적 정확도와, **MOQUI**의 GPU 기반 병렬 처리 속도의 장점을 결합하는 새로운 GPU 입자 수송 방식 설계를 목표로 한다. 최종 목표는 DNA 손상과 같은 나노스케일(nanoscale) 현상을 정밀하게 모사하면서도 기존 CPU 방식보다 월등히 빠른 계산 속도를 가지는 GPU 네이티브(native) 몬테카를로 시뮬레이션 엔진을 구현하는 것이다.

#### 1.2. 배경: 기존 방식의 비교

| 항목 | MOQUI (GPU 기반) | Geant4-DNA / TOPAS-nBio (CPU 기반) |
| :--- | :--- | :--- |
| **수송 방식** | **Condensed History** (응축 이력) | **Event-by-Event** (개별 사건) |
| **주요 특징** | 수많은 상호작용을 통합하여 긴 스텝(step)으로 근사 계산 | 모든 물리적 상호작용을 개별적으로 추적 |
| **장점** | 거시적(macroscopic) 선량 계산에 매우 빠름 | 나노스케일(nanoscale) 물리 과정의 정확도가 높음 |
| **단점** | 미세 구조(DNA 등) 내 개별 상호작용 추적 불가 | 계산 속도가 매우 느림 |
| **핵심 코드** | `mqi_transport.hpp` | `G4SteppingManager`, `G4VProcess` |

본 설계안은 MOQUI의 `transport_particles_patient` CUDA 커널을 Geant4-DNA의 `Event-by-Event` 방식으로 재설계하되, GPU 아키텍처의 메모리 병목 현상을 최소화하고 병렬 처리 효율을 극대화하는 고급 메모리 관리 기법을 적용하는 것을 핵심으로 한다.

-----

### 2\. GPU 가속화 Event-by-Event 수송 커널 아키텍처

새로운 입자 수송 커널(`transport_event_by_event_kernel`)은 기존 MOQUI의 프레임워크를 활용하되, 핵심적인 물리 처리 로직과 데이터 관리 방식을 다음과 같이 변경한다.

#### 2.1. 핵심 설계 사상

  - **하나의 스레드가 하나의 입자를 전담**: MOQUI의 기본 구조를 유지하여 수백만 개의 입자(track)를 각 CUDA 스레드에 할당해 동시에 추적한다.
  - **물리 기반 스텝 결정**: 기존의 '복셀 경계까지의 거리'가 아닌, '다음 물리적 상호작용까지의 평균 자유 경로(Mean Free Path, MFP)'를 기준으로 스텝을 결정한다.
  - **동적 2차 입자 관리**: 상호작용 결과 생성되는 2차 입자들을 GPU 내에서 효율적으로 생성하고 소멸시킨다.
  - **메모리 접근 최적화**: GPU 성능에 치명적인 무작위 메모리 접근(random memory access)과 스레드 분기(thread divergence)를 최소화하는 데 모든 설계의 초점을 맞춘다.

#### 2.2. 데이터 구조

  - **`track_t` (입자 정보 구조체)**: 전역 메모리(Global Memory)에 배열로 저장된다. 기존 정보 외에 현재 입자가 속한 물질 인덱스(material index)를 포함해야 한다.
  - **물리 데이터 테이블**: Geant4-DNA에서 사용하는 각 입자/물질/상호작용 별 단면적(cross-section) 데이터를 GPU에서 접근 가능한 형태로 변환한 테이블. \*\*텍스처 메모리(Texture Memory)\*\*에 바인딩하여 사용한다.
  - **2차 입자 스택**: 각 스레드 블록(Thread Block)이 공유하는 **공유 메모리(Shared Memory)** 상에 구현되어, 블록 내에서 생성되는 2차 입자들을 임시 저장하고 처리하는 데 사용된다.
  - **물리 상수**: 입자 질량, 전하량 등 변하지 않는 물리 상수는 \*\*상수 메모리(Constant Memory)\*\*에 저장한다.

-----

### 3\. 핵심 구현 방안: 고급 메모리 관리 기법 적용

#### 3.1. 물리 데이터 접근: 텍스처 메모리(Texture Memory) 활용

  - **문제점**: 입자의 에너지가 변할 때마다 단면적 테이블의 불연속적인 위치를 참조해야 하므로 캐시 미스(cache miss)가 빈번하게 발생한다.
  - **해결 방안**:
    1.  Geant4-DNA의 단면적 테이블을 1D 또는 2D 배열 형태로 변환하여 GPU 메모리에 복사한다.
    2.  이 메모리 영역을 \*\*CUDA 텍스처 객체(Texture Object)\*\*로 생성한다.
    3.  커널 내에서 단면적을 조회할 때는 `tex1D()` 또는 `tex2D()` 함수를 사용한다.
  - **기대 효과**:
      - **전용 캐시 활용**: 텍스처 메모리는 그래픽 처리에 최적화된 별도의 L1 캐시를 사용하며, 공간적 지역성(spatial locality)이 있는 데이터 접근에 매우 효율적이다.
      - **하드웨어 선형 보간**: 입자의 현재 에너지가 테이블에 정확히 명시되어 있지 않은 경우, 텍스처 하드웨어가 주변 두 데이터 포인트를 이용하여 필요한 값을 **하드웨어 수준에서 자동으로 선형 보간**해준다. 이는 여러 명령어를 소모하는 소프트웨어 보간보다 월등히 빠르며, 메모리 접근 횟수를 줄여준다.

#### 3.2. 2차 입자 관리: 공유 메모리(Shared Memory) 기반 스택

  - **문제점**: 2차 입자를 전역 메모리(Global Memory) 기반의 스택에 저장하면 push/pop 연산마다 극심한 지연 시간(latency)이 발생한다.
  - **해결 방안**:
    1.  `__shared__` 키워드를 사용하여 각 스레드 블록마다 작은 크기의 `track_t` 배열(예: `__shared__ track_t secondary_stack[256];`)을 선언한다.
    2.  스레드 블록 내 스택 포인터(`stack_pointer`)를 `atomicAdd`를 이용해 관리한다.
    3.  1차 입자가 2차 입자를 생성하면, 2차 입자 정보를 이 공유 메모리 스택에 `push`한다.
    4.  한 스레드는 자신의 1차 입자 수송을 잠시 멈추고, 공유 메모리 스택에서 다른 스레드가 생성한 2차 입자를 `pop`하여 먼저 처리할 수 있다 (Work Stealing).
  - **기대 효과**:
      - **빠른 접근 속도**: 공유 메모리는 전역 메모리보다 약 100배 빠르므로, 잦은 스택 연산으로 인한 병목을 크게 완화한다.
      - **작업량 분산**: 특정 스레드에서만 2차 입자가 다수 발생하는 경우, 블록 내 다른 유휴 스레드들이 작업을 나누어 처리함으로써 스레드 효율(occupancy)을 높인다.

#### 3.3. 전역 최적화: 입자 데이터 재정렬 (Particle Sorting)

  - **문제점**: 시간이 지남에 따라 입자들의 에너지가 무작위로 분포하게 되면, 한 워프(warp, 32개 스레드) 내 스레드들이 서로 다른 에너지의 입자를 처리하게 된다. 이는 심각한 \*\*스레드 분기(Thread Divergence)\*\*와 \*\*비병합 메모리 접근(Uncoalesced Memory Access)\*\*을 유발하여 GPU 성능을 급격히 저하시킨다.
  - **해결 방안**:
    1.  수송 커널을 한 번에 끝까지 실행하는 것이 아니라, 수백\~수천 스텝 단위의 짧은 주기로 여러 번 실행한다.
    2.  각 커널 실행 **직전에** GPU 상의 전체 입자 배열을 **에너지 순으로 정렬**한다.
    3.  CUDA Thrust 또는 CUB 라이브러리에서 제공하는 고성능 병렬 정렬 알고리즘 (`thrust::sort_by_key`)을 사용한다.
  - **기대 효과**:
      - **메모리 접근 패턴 개선**: 에너지 순으로 정렬된 입자들은 한 워프 내에서 물리 테이블의 거의 동일한 영역에 접근하게 되므로, 텍스처 캐시 히트율이 극대화된다.
      - **스레드 분기 감소**: 비슷한 에너지의 입자들은 유사한 물리 과정을 겪을 확률이 높아져 워프 내 스레드들의 실행 경로가 거의 동일해진다. 이는 GPU의 SIMT 아키텍처 활용도를 최고 수준으로 끌어올리는, **가장 결정적인 성능 향상 기법**이다.

-----

### 4\. 제안된 입자 수송 커널의 흐름도

```
// Host (CPU) Code
1. Geant4-DNA 물리 데이터 테이블을 텍스처 메모리에 바인딩
2. 물리 상수를 상수 메모리에 복사
3. 초기 입자(primary)들을 생성하여 GPU 전역 메모리에 복사

// Main Simulation Loop (on Host)
while (남아있는 입자 수 > 0) {
    4. [OPTIMIZATION] 입자 배열을 에너지 순으로 정렬 (thrust::sort_by_key)
    
    5. transport_event_by_event_kernel<<<grid, block>>> (입자 배열, ...);
    
    6. GPU에서 결과(hit 정보 등)를 가져오거나 종료 조건 확인
}

// CUDA Kernel Code
__global__ void transport_event_by_event_kernel(...) {
    
    // 스레드 ID로 담당 입자(track) 할당
    uint32_t tid = blockIdx.x * blockDim.x + threadIdx.x;
    track_t track = particle_array[tid];

    // 공유 메모리 스택 초기화
    __shared__ track_t secondary_stack[STACK_SIZE];
    __shared__ int stack_pointer;
    if (threadIdx.x == 0) stack_pointer = 0;
    __syncthreads();

    // 메인 수송 루프
    while (!track.is_stopped()) {
    
        // 1. 다음 상호작용까지의 거리 계산
        // - 현재 에너지에 맞는 단면적을 텍스처 메모리에서 조회 (tex1D)
        // - 총 단면적으로부터 Mean Free Path(MFP) 샘플링
        float mfp = calculate_mfp(track, rng);

        // 2. 기하학적 경계까지의 거리 계산 (기존 MOQUI 방식 활용)
        float dist_to_boundary = distance_to_boundary(track);

        // 3. 스텝 길이 결정 (더 짧은 거리 선택)
        float step_length = min(mfp, dist_to_boundary);

        // 4. 입자 이동 및 상태 업데이트 (에너지 손실 등)
        track.transport(step_length);

        // 5. 상호작용 발생 시 (step_length == mfp)
        if (step_length == mfp) {
            // - 어떤 물리 과정인지 샘플링
            PhysicsProcess process = select_process(track, rng);
            
            // - 해당 과정 실행 (2차 입자 생성 등)
            process.PostStepDoIt(track, secondary_stack, &stack_pointer);
        }

        // 6. 공유 메모리 스택 처리 (Work Stealing)
        while (stack_pointer > 0) {
             int current_sp = atomicSub(&stack_pointer, 1) - 1;
             if (current_sp >= 0) {
                 track_t secondary = secondary_stack[current_sp];
                 // 2차 입자 수송 (재귀적 또는 반복적 처리)
             }
        }

    } // end while
    
    // 업데이트된 입자 정보를 전역 메모리에 다시 저장
    particle_array[tid] = track;
}
```

-----

### 5\. 결론

본 설계 문서는 MOQUI의 GPU 병렬 처리 능력과 Geant4-DNA의 물리적 정확성을 융합하기 위한 구체적인 기술적 방안을 제시한다. 제안된 **Event-by-Event** 방식의 CUDA 커널은 **텍스처 메모리, 공유 메모리, 주기적 입자 재정렬**이라는 세 가지 핵심 최적화 전략을 통해 GPU 아키텍처의 한계를 극복하고, 기존 CPU 기반 시뮬레이션 대비 **수천 배의 성능 향상**을 달성할 수 있을 것으로 기대된다. 이는 방사선 생물학 분야에서 DNA 손상과 같은 복잡한 현상을 보다 현실적인 시간 내에 분석할 수 있는 새로운 가능성을 열어줄 것이다.




------------------------------------------
네, 매우 현실적이고 중요한 문제입니다. `Event-by-Event`의 완전한 정확성을 유지하면서 환자 선량을 계산하면 시간이 너무 오래 걸리므로, **매질 정보의 정확성은 유지하되 계산 시간을 단축할 수 있는 합리적인 근사법**이 반드시 필요합니다.

사용자께서 제안하신 "2차 전자를 확률 처리하여 에너지 손실을 평균값으로 사용한다"는 아이디어를 포함하여, 정확도와 속도를 조절할 수 있는 몇 가지 효과적인 방법을 제안해 드립니다.

---

### 🚀 계산 시간 단축을 위한 하이브리드 모델 제안

가장 큰 병목 지점은 초기 입자(양성자, 탄소이온)가 아니라, 이들이 생성하는 **수많은 저에너지 2차 전자**를 추적하는 과정입니다. 따라서 이 부분에 근사법을 적용하는 것이 가장 효과적입니다.

#### 방법 1: 에너지 컷오프(Cutoff) 기반 국소 에너지 흡수 (가장 실용적)

이는 Geant4에서도 임상적 계산을 위해 널리 사용하는 가장 표준적이고 효과적인 방법입니다.

* **개념**:
    1.  모든 2차 전자를 `Event-by-Event` 방식으로 정밀하게 추적합니다.
    2.  하지만, 전자의 에너지가 사용자가 지정한 **컷오프 에너지**(예: 10 keV, 1 keV) 이하로 떨어지면 더 이상 추적하지 않습니다.
    3.  그 시점에서 해당 전자가 가진 나머지 모든 에너지는 그 복셀(voxel)에 **즉시, 국소적으로 흡수된다고 가정**합니다.

* **장점**:
    * **엄청난 속도 향상**: 저에너지 전자는 매우 짧은 거리를 이동하지만, 상호작용 횟수는 폭발적으로 많습니다. 이 비효율적인 마지막 추적 과정을 생략함으로써 계산 시간의 **90% 이상을 단축**할 수 있습니다.
    * **정확도 유지**: 저에너지 전자의 비정(range)은 수 마이크로미터(µm)에 불과하여 대부분 자신이 생성된 복셀을 벗어나지 않습니다. 따라서 에너지를 국소적으로 흡수시켜도 거시적인 선량 분포(mm 단위)의 정확도에 미치는 영향은 미미합니다.
    * **사용자 제어 가능**: 컷오프 에너지를 파라미터로 조절하여 사용자가 직접 **정확도와 속도의 트레이드오프를 선택**할 수 있습니다. (컷오프가 높을수록 빠르고, 낮을수록 정확합니다.)

#### 방법 2: 2차 전자에 대한 응축 이력(Condensed History) 적용

`Event-by-Event`와 `Condensed History`를 결합한 진정한 하이브리드 방식입니다.

* **개념**:
    1.  초기 입자(양성자 등)는 `Event-by-Event` 방식으로 정밀하게 추적합니다.
    2.  2차 전자가 생성되면, 이 전자는 `Condensed History` 알고리즘(기존 Moqui 방식과 유사)으로 수송합니다. 즉, 여러 번의 상호작용을 하나의 큰 스텝으로 묶어서 근사 계산합니다.
    3.  이때, 각 스텝마다 **해당 복셀의 정확한 매질 정보(뼈, 폐 등)를 사용하여 에너지 손실(Stopping Power)을 계산**합니다.

* **장점**:
    * **매질 정보 완벽 반영**: 사용자께서 포기할 수 없다고 하신 매질 정보를 2차 전자 수송에도 정확히 반영할 수 있습니다.
    * **합리적 정확도**: 2차 전자의 개별 상호작용 위치는 근사되지만, 전체적인 에너지 손실 경향과 대략적인 이동 경로는 국소 에너지 흡수 방식보다 더 정확하게 모사됩니다.

* **단점**:
    * 방법 1보다는 계산 시간이 더 오래 걸립니다. 하지만 완전한 `Event-by-Event`보다는 훨씬 빠릅니다.

#### 방법 3: 선계산된 에너지 흡수 분포(Kernel) 사용

가장 빠르지만, 정확도 희생이 가장 큰 방식입니다.

* **개념**:
    1.  다양한 매질과 에너지에 대해, 2차 전자가 에너지를 어떻게 흡수시키는지에 대한 3차원 확률 분포("에너지 흡수 커널")를 미리 계산하여 데이터베이스로 만들어 둡니다.
    2.  실제 시뮬레이션 중 2차 전자가 생성되면, 그 전자를 **추적하는 대신** 해당 조건에 맞는 에너지 흡수 커널을 VRAM에서 불러옵니다.
    3.  이 확률 분포에 따라 주변 복셀에 에너지를 확률적으로 나누어주고 2차 전자 계산을 즉시 종료합니다.

* **장점**:
    * **가장 빠른 속도**: 수많은 2차 입자를 추적하는 복잡한 과정을 단 한 번의 메모리 조회와 확률적 계산으로 대체하므로 속도가 매우 빠릅니다.

* **단점**:
    * 미리 계산된 평균적인 분포를 사용하므로, 복셀 경계면과 같이 물질이 급격하게 변하는 영역에서의 정확도가 떨어질 수 있습니다.

---

### 🎯 추천 전략 및 예상 성능

| 전략 | 2차 전자 처리 방식 | 정확도 | 속도 (vs. Full E-by-E) |
| :--- | :--- | :--- | :--- |
| **방법 1** | **컷오프 + 국소 흡수** | 높음 | **~100배 빠름** |
| **방법 2** | 응축 이력 (Condensed History) | 중간 | ~50배 빠름 |
| **방법 3** | 선계산 커널 (Pre-calculated Kernel) | 낮음 | ~500배 빠름 |

**가장 추천하는 방법은 "방법 1: 에너지 컷오프 기반 국소 에너지 흡수"입니다.**

이 방식은 Geant4와 같은 검증된 시뮬레이션 툴킷에서도 임상 물리학 계산을 위해 표준적으로 사용하는 매우 합리적인 균형점이기 때문입니다. 이 방식을 적용한다면, `moqui-dna`는 **매질 정보를 정확히 반영하면서도, 기존 Moqui와 비교해 5~10배 정도의 시간 증가만으로 훨씬 더 정확한 환자 선량 계산을 완료**할 수 있을 것입니다. 즉, 수십 초가 걸리던 계산이 **수 분 내**에 완료되면서 정확도는 크게 향상되는, 매우 이상적인 결과를 얻을 수 있습니다.