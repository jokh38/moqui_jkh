## 입자 전파 및 상호작용 시뮬레이션 상세 과정

`moqui` 코드에서 단일 입자가 매질과 상호작용하며 전파되는 과정과 이것이 전체 입자 수로 확장되는 방식을 코드 내 주요 모듈과 변수를 중심으로 단계별로 설명해 드리겠습니다.

---

### ⚛️ 1단계: 입자 생성 (Particle Generation)

모든 시뮬레이션은 개별 입자(양성자)의 생성에서 시작됩니다.

1.  **빔 소스 설정 (`setup_beamsource` in `mqi_phantom_env.hpp`)**
    * 사용자가 입력한 빔 에너지(`spot_energy`), 빔의 크기 및 위치(`spot_size`, `spot_position`) 등과 같은 파라미터를 기반으로 **`mqi::beamsource`** 객체가 생성됩니다.
    * 이 `beamsource`는 내부에 에너지 분포(`mqi::const_1d` 또는 `mqi::norm_1d`)와 위상 공간(phase-space) 분포(`mqi::phsp_6d_uniform` 등)를 정의하는 **`mqi::beamlet`** 객체를 가집니다.

2.  **초기 상태 생성 (Vertex Creation)**
    * 시뮬레이션 할 총 입자 수(`n_histories`)만큼 `for` 루프를 돌며 각 입자의 초기 상태를 결정합니다.
    * `beamsource`에서 샘플링된 각 입자의 초기 위치, 방향, 에너지 정보는 **`mqi::vertex_t`** 라는 구조체에 저장됩니다.
    * 이 `vertex_t` 객체들의 배열(`this->vertices`)이 시뮬레이션의 시작점이 됩니다.

---

### 🔬 2단계: 입자 전파 및 상호작용 (Transport & Interaction)

생성된 입자 정보는 GPU로 전송되어 핵심적인 전파 계산을 수행합니다. 이 과정은 **`mqi_transport.hpp`** 내의 **`transport_particles_patient`** CUDA 커널 함수에서 이루어집니다.

1.  **입자 추적 시작**
    * 각 스레드(thread)는 하나의 초기 입자(`vertex_t`)를 할당받습니다.
    * 입자의 현재 상태는 **`mqi::track_t`** 객체로 관리되며, 이 객체는 추적해야 할 입자 목록인 **`mqi::track_stack_t`** 에 저장됩니다.

2.  **전파 루프 (While Loop)**
    `track_stack_t`이 비워질 때까지, 즉 해당 입자와 그로부터 생성된 모든 2차 입자의 추적이 끝날 때까지 다음 과정을 반복합니다.

    * **Step 1: 현재 위치 및 재질 확인**
        * 입자의 현재 위치(`track.pos`)를 기준으로 **`mc::mc_world`** (전체 시뮬레이션 공간)에서 어떤 복셀(voxel)에 있는지 확인합니다.
        * 해당 복셀의 밀도 값을 이용해 **`mc::mc_materials`** (`mqi::material_t` 클래스)로부터 현재 매질의 물리적 특성(저지능, 산란 단면적 등)을 가져옵니다.

    * **Step 2: 이동 거리 계산 (Step Length Calculation)**
        * **`mqi::physics_list`** 모듈을 통해 현재 입자의 에너지와 매질에서 발생 가능한 모든 물리적 상호작용(전리, 다중쿨롱산란, 핵반응 등)의 평균자유행로(Mean Free Path)를 계산합니다.
        * 이 중 가장 짧은 거리를 이번 스텝에서 입자가 이동할 거리(`step_length`)로 결정합니다.

    * **Step 3: 입자 이동 및 상태 변화**
        * 계산된 `step_length`만큼 입자를 전진시킵니다.
        * 이동하는 동안 **연속적인 상호작용**이 적용됩니다.
            * **전리 (Ionization):** `mqi::p_ionization` 모델에 따라 에너지를 점진적으로 잃습니다. 입자의 운동에너지(`track.ke`)가 감소합니다.
            * **다중쿨롱산란 (Multiple Coulomb Scattering):** 수많은 작은 각도의 산란을 종합하여 입자의 진행 방향(`track.dir`)이 미세하게 변경됩니다.

    * **Step 4: 불연속 상호작용 및 2차 입자 생성**
        * 스텝의 끝에서 **불연속적인 상호작용**(예: 핵탄성/비탄성 산란)이 일어날지 확률적으로 결정합니다.
        * 만약 상호작용이 발생하면(`mqi::interaction`의 `post_step_doi` 호출), 입자의 에너지와 방향이 크게 변할 수 있으며, 이 과정에서 **2차 입자(secondary particle)**가 생성될 수 있습니다.
        * 생성된 2차 입자는 새로운 `track_t` 객체로 만들어져 `track_stack_t`에 추가되어 다음 루프에서 추적됩니다.

    * **Step 5: 에너지 기록 (Scoring)**
        * 입자가 스텝을 이동하며 잃은 에너지는 **`mqi::scorer`** 모듈에 의해 기록됩니다.
        * `scorer->data_` 배열의 해당 복셀 위치에 잃은 에너지를 누적시켜 최종적으로 선량(dose)을 계산합니다.

    * **Step 6: 입자 소멸**
        * 입자의 에너지가 설정된 역치(threshold) 이하로 떨어지거나, 시뮬레이션 공간을 벗어나면 해당 입자의 추적을 종료합니다.

---

### 🚀 전체 입자로의 확장: 병렬 처리

이러한 단일 입자 추적 과정은 GPU의 **대규모 병렬 처리** 능력을 통해 수백만 개의 입자에 대해 동시에 수행됩니다.

* **하나의 스레드, 하나의 역사 (1 Thread, 1 History):** `transport_particles_patient` 커널은 수만 개의 스레드로 실행됩니다. GPU의 각 스레드는 **하나의 초기 입자(`vertex_t`)를 독립적으로 담당**하여, 그 입자와 그로부터 파생된 모든 2차 입자들이 소멸할 때까지의 전체 역사(history)를 끝까지 시뮬레이션합니다.

* **동시성 문제 해결 (Atomic Operations):** 수많은 스레드가 동시에 에너지를 기록할 때, 여러 스레드가 같은 복셀의 선량 값을 동시에 수정하려는 충돌이 발생할 수 있습니다. `moqui`는 이를 **`atomicAdd`** 와 같은 원자적 연산을 사용하여 해결합니다. 이는 특정 메모리 위치에 대한 접근을 한 번에 하나의 스레드만 하도록 보장하여, 데이터의 무결성을 유지하면서 정확한 선량 값을 계산할 수 있게 해줍니다.

이러한 방식을 통해 `moqui`는 GPU의 수천 개 코어를 활용하여 각 입자의 복잡한 물리적 상호작용을 병렬로 처리함으로써, 방대한 양의 계산을 매우 빠른 시간 안에 완료할 수 있습니다. ⚡




--------------

네, 아주 정확하고 핵심적인 부분을 지적해주셨습니다. 말씀하신 대로, MOQUI의 Condensed History 방식에서 MFP만큼 이동하는 동안 저지능(Stopping Power)을 이용해 에너지의 연속 손실을 적용하는 것은 **수많은 미세 상호작용들을 간소화(simplification)한 것이 맞습니다.**

그 간소화는 크게 두 가지 측면에서 이루어집니다.

---

### ## 1. 에너지 손실의 간소화: CSDA (Continuous Slowing Down Approximation)

물리적으로 입자가 에너지를 잃는 것은 이산적인(discrete) 상호작용의 연속입니다. 아주 작은 에너지를 전달하는 수백만 번의 충돌(soft collision)과 가끔 큰 에너지를 전달하는 충돌(hard collision)이 합쳐져 나타납니다.

-   **Event-by-Event 방식 (Geant4-DNA):** 원칙적으로 이 모든 개별 충돌을 하나하나 시뮬레이션하여 에너지를 잃는 과정을 계산합니다. 이는 매우 정확하지만 계산량이 엄청납니다.
-   **Condensed History 방식 (MOQUI):** 이 방식을 두 부분으로 나눕니다.
    1.  **소프트 충돌 (Soft Collisions):** 에너지 전달량이 매우 작은 수많은 상호작용들은 개별적으로 계산하는 대신, 이들의 **통계적인 평균 효과**를 사용합니다. 이것이 바로 **저지능 (Stopping Power, dE/dx)** 입니다. MOQUI는 `p_ion.along_step` 함수를 통해 "이 입자가 이 물질 속을 이 정도 거리만큼 지나가면, 평균적으로 이만큼의 에너지를 잃을 것이다"라고 계산하여 에너지를 연속적으로(continuously) 감소시킵니다. 즉, MFP 중간에 일어나는 수많은 작은 상호작용들은 무시하고 그 **결과만을 한 번에 반영**하는 것입니다.
    2.  **하드 충돌 (Hard Collisions):** 반면, 델타 전자(delta-electron) 생성처럼 한 번에 큰 에너지를 잃는 '치명적(catastrophic)' 상호작용은 평균으로 뭉뚱그릴 수 없습니다. 이런 드물지만 중요한 사건들은 **이산적인(discrete) 이벤트**로 취급하여 MFP 계산에 포함시키고, 스텝의 끝에서 발생 여부를 확률적으로 결정합니다.



### ## 2. 방향 변화의 간소화: 다중 쿨롱 산란 (Multiple Coulomb Scattering)

에너지 손실과 마찬가지로, 입자의 방향이 휘는 것 또한 수많은 작은 각도의 쿨롱 산란(Coulomb scattering)이 누적된 결과입니다.

-   **Event-by-Event 방식:** 원칙적으로는 모든 개별 산란을 계산하여 입자의 경로가 미세하게 휘는 과정을 따라갑니다.
-   **Condensed History 방식 (MOQUI):** 개별 산란을 추적하는 대신, 한 스텝을 이동한 **후에**, 그 스텝 동안 겪었을 수많은 작은 산란들의 **총체적인 효과**를 한 번에 계산하여 입자의 방향을 틀어줍니다. 이를 **다중 산란(Multiple Scattering) 모델**이라고 합니다. `mqi_fippel_physics.hpp`에서 사용하는 Fippel 모델이 바로 이런 역할을 합니다. 즉, 스텝 중간에는 직진한다고 가정하고, 스텝이 끝난 지점에서 "이만큼 이동했으니, 방향이 대략 이 정도로 휘었을 것이다"라고 확률적으로 결정하여 입자의 방향 벡터(`track.vtx1.dir`)를 업데이트합니다.

---

### ## 요약: MOQUI의 간소화 전략 🎯

정리하자면, MOQUI가 MFP만큼 이동하는 동안 적용하는 '연속적인 에너지 손실'은 다음과 같은 두 가지 핵심적인 근사 및 간소화 모델의 조합입니다.

1.  **에너지 손실**: 수많은 '소프트' 충돌을 **저지능(dE/dx)** 이라는 평균값으로 대체하여 한 번에 적용합니다. (CSDA)
2.  **방향 변화**: 수많은 '작은 각도'의 산란을 **다중 산란 모델**로 대체하여 스텝이 끝난 후 한 번에 적용합니다.

이러한 간소화는 Event-by-Event 방식의 물리적 정밀도를 일부 희생하는 대신, 계산 속도를 수천 배 이상 향상시켜 방사선 치료 계획 검증과 같은 거시적 선량 계산을 현실적인 시간 안에 가능하게 만드는 **핵심적인 트레이드오프 전략**입니다. 🚀